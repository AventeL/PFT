# Story 4.5: Timer en background

## Status
**Draft**

---

## Story

**As a** utilisateur,  
**I want to** que le timer continue si je minimise l'app,  
**so that** je peux check mes messages sans perdre le timing.

---

## Acceptance Criteria

1. Timer continue en background quand app minimisée
2. Notification persistante affiche countdown en temps réel
3. Notification cliquable ramène à l'app
4. Sync état au retour en foreground
5. Timer survit aux interruptions (appels, etc.)
6. Notification disparaît à la fin du timer

---

## Tasks / Subtasks

### Background Execution Setup
- [ ] **Task 1: Configure App for Background Execution** (AC: 1, 5)
  - [ ] Subtask 1.1: Android - Configure foreground service
    - Add permissions in AndroidManifest.xml
    - `FOREGROUND_SERVICE`, `WAKE_LOCK`
  - [ ] Subtask 1.2: iOS - Configure background modes
    - Add audio background mode (timer as "audio" app)
    - Or use local notifications with scheduled triggers

### Persistent Notification
- [ ] **Task 2: Implement Persistent Notification** (AC: 2, 3, 6)
  - [ ] Subtask 2.1: Create persistent notification on timer start
    - Title: "Rest Timer"
    - Content: "2:45 remaining"
    - Icon: Timer icon
    - Priority: High (always visible)
    - `ongoing: true` (not dismissible during timer)
  - [ ] Subtask 2.2: Update notification every second
    - Listen to TimerBloc state
    - Update notification content with remaining time
  - [ ] Subtask 2.3: Make notification tappable
    - Intent: Open app to ActiveWorkoutScreen
    - Clear notification on tap
  - [ ] Subtask 2.4: Remove notification on timer complete
    - Auto-dismiss when timer reaches 0

### App Lifecycle Management
- [ ] **Task 3: Handle App Lifecycle Events** (AC: 1, 4, 5)
  - [ ] Subtask 3.1: Listen to app lifecycle changes
    - `AppLifecycleState` observer
    - Detect paused, resumed, inactive
  - [ ] Subtask 3.2: On app paused (minimized)
    - Show persistent notification
    - Timer continues in background
  - [ ] Subtask 3.3: On app resumed (brought back)
    - Hide persistent notification
    - Sync timer state from BLoC
    - Update UI with current remaining time
  - [ ] Subtask 3.4: Handle interruptions (calls, alarms)
    - Timer keeps running
    - Resume after interruption ends

### Timer State Persistence
- [ ] **Task 4: Persist Timer State** (AC: 4)
  - [ ] Subtask 4.1: Save timer state to SharedPreferences
    - Remaining duration
    - Start timestamp
    - Timer status (running/paused)
  - [ ] Subtask 4.2: Restore timer on app restart
    - Calculate remaining time based on elapsed
    - Resume timer if still valid
  - [ ] Subtask 4.3: Clear persisted state on timer complete

### Android Foreground Service
- [ ] **Task 5: Implement Android Foreground Service** (AC: 1)
  - [ ] Subtask 5.1: Create TimerService (optional, if using service)
    - Keeps timer alive in background
    - Shows persistent notification
  - [ ] Subtask 5.2: Alternative: Use WorkManager
    - Schedule countdown updates
    - More battery-efficient
  - [ ] Subtask 5.3: Recommendation: Simple approach
    - Use Timer with persistent notification
    - No heavy service needed for MVP

### iOS Background Handling
- [ ] **Task 6: Implement iOS Background Support** (AC: 1)
  - [ ] Subtask 6.1: iOS limitations
    - iOS doesn't allow true background timers
    - Use local notifications scheduled at specific times
  - [ ] Subtask 6.2: Schedule notification for timer end
    - Calculate end time (now + duration)
    - Schedule local notification at that time
  - [ ] Subtask 6.3: Silent audio trick (optional)
    - Play silent audio to keep app "active"
    - Not recommended (drains battery)

### Testing
- [ ] **Task 7: Test Background Behavior**
  - [ ] Subtask 7.1: Test timer continues when app minimized
  - [ ] Subtask 7.2: Test notification updates every second
  - [ ] Subtask 7.3: Test notification tap returns to app
  - [ ] Subtask 7.4: Test timer completes in background
  - [ ] Subtask 7.5: Test interruptions (calls, etc.)
  - [ ] Subtask 7.6: Test battery impact

---

## Dev Notes

### Project Structure
**Source:** [PRD Feature 4 - US-4.5]

Modified files:
```
android/app/src/main/AndroidManifest.xml (MODIFY - add permissions)
ios/Runner/Info.plist (MODIFY - background modes)

lib/
├── core/
│   └── services/
│       └── notification_service.dart (MODIFY - persistent notification)
└── presentation/
    └── blocs/timer/
        └── timer_bloc.dart (MODIFY - lifecycle handling)
```

### Android Permissions
**Source:** [PRD Feature 4 - US-4.5 AC]

**AndroidManifest.xml:**
```xml
<uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
```

### Persistent Notification
**Source:** [PRD Feature 4 - US-4.5 AC]

**Create ongoing notification:**
```dart
void showPersistentTimerNotification(Duration remaining) {
  flutterLocalNotificationsPlugin.show(
    0,
    'Rest Timer',
    formatDuration(remaining) + ' remaining',
    NotificationDetails(
      android: AndroidNotificationDetails(
        'timer_channel',
        'Timer',
        importance: Importance.high,
        priority: Priority.high,
        ongoing: true, // Not dismissible
        autoCancel: false,
        showWhen: false,
      ),
      iOS: DarwinNotificationDetails(
        presentAlert: true,
        presentBadge: true,
      ),
    ),
  );
}
```

**Update notification:**
```dart
// In TimerBloc, listen to state changes
_timerBloc.stream.listen((state) {
  if (state is TimerRunning && _appInBackground) {
    _notificationService.showPersistentTimerNotification(state.remaining);
  }
});
```

### App Lifecycle Handling
**Source:** [PRD Feature 4 - US-4.5 AC]

**WidgetsBindingObserver:**
```dart
class ActiveWorkoutScreen extends StatefulWidget with WidgetsBindingObserver {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }
  
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.paused) {
      // App minimized
      _appInBackground = true;
      if (_timerRunning) {
        _notificationService.showPersistentTimerNotification(_remaining);
      }
    } else if (state == AppLifecycleState.resumed) {
      // App back in foreground
      _appInBackground = false;
      _notificationService.cancelPersistentNotification();
    }
  }
}
```

### Timer State Persistence
**Source:** [PRD Feature 4 - US-4.5 AC]

**Save state:**
```dart
void _saveTimerState(Duration remaining) {
  _prefs.setInt('timer_remaining_seconds', remaining.inSeconds);
  _prefs.setInt('timer_start_timestamp', DateTime.now().millisecondsSinceEpoch);
  _prefs.setBool('timer_running', true);
}
```

**Restore state:**
```dart
void _restoreTimerState() {
  final remainingSeconds = _prefs.getInt('timer_remaining_seconds');
  final startTimestamp = _prefs.getInt('timer_start_timestamp');
  final wasRunning = _prefs.getBool('timer_running') ?? false;
  
  if (wasRunning && remainingSeconds != null && startTimestamp != null) {
    final elapsed = DateTime.now().millisecondsSinceEpoch - startTimestamp;
    final newRemaining = Duration(seconds: remainingSeconds) - Duration(milliseconds: elapsed);
    
    if (newRemaining > Duration.zero) {
      // Resume timer
      add(ResumeTimer(newRemaining));
    } else {
      // Timer completed while app was closed
      add(TimerComplete());
    }
  }
}
```

### iOS Background Limitations
**Source:** iOS Platform**

**Challenges:**
- iOS doesn't allow true background execution for fitness apps
- Timer will pause after ~10 seconds in background

**Solutions:**
1. **Scheduled notification (Recommended):**
   - Calculate timer end time
   - Schedule local notification at that time
   - User gets alert when timer completes (even if app closed)

2. **Background audio (Not recommended):**
   - Play silent audio to keep app active
   - Drains battery significantly

**Implementation (scheduled notification):**
```dart
void scheduleTimerCompleteNotification(Duration duration) {
  final endTime = DateTime.now().add(duration);
  
  flutterLocalNotificationsPlugin.zonedSchedule(
    0,
    'Rest Timer Complete',
    'Your rest period is over. Time to get back to work!',
    tz.TZDateTime.from(endTime, tz.local),
    NotificationDetails(...),
    uiLocalNotificationDateInterpretation: ...,
  );
}
```

### Battery Optimization
**Source:** Best Practices**

**Minimize battery impact:**
- Use `Timer` instead of heavy background service
- Update notification max every 1 second (not more frequent)
- Stop notification updates when app in foreground
- Cancel timer if battery critical

### Testing Strategy
**Source:** [PRD Feature 4 - US-4.5]

**Test scenarios:**
1. Start timer → Minimize app → Wait 30s → Check notification updates
2. Start timer → Minimize app → Wait until complete → Check completion alert
3. Start timer → Minimize app → Tap notification → Verify app opens
4. Start timer → Receive phone call → Hang up → Timer continues
5. Start timer → Force quit app → Reopen → Timer state restored (optional)

### Performance Considerations
**Source:** [PRD Feature 4 - US-4.5]

- **Battery impact:** ~1-2% per hour (acceptable for fitness app)
- **Notification update rate:** 1 per second
- **Memory:** Minimal (just timer state)

### Dependencies
**Source:** [PRD Technical Architecture]

Packages (already in project):
- `flutter_local_notifications: ^16.3.0`
- `shared_preferences: ^2.2.0`

### Testing Standards

**Manual Testing Required:**
- Test on physical Android device
- Test on physical iPhone
- Check battery drain over 10 minutes
- Test with various interruptions

**Key Test Cases:**
- Timer continues in background (Android)
- Notification updates correctly
- Tap notification returns to app
- Timer completes in background
- State syncs on foreground return

### Integration with Other Stories
**Dependencies:**
- Story 4.1 (Auto Timer) - Timer to run in background
- Story 4.2 (Notifications) - Notification system

**Enables:**
- True hands-free timer experience
- User can use phone during rest
- No need to keep app open

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-11 | 1.0 | Initial story creation from PRD | Mathis (PM) |

---

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

---

## QA Results
_To be filled by QA agent_

